/*
 * FSM-1.c
 *
 *  Created on: Sep 18, 2024
 *      Author: ijk95
 */


#include "FSM-1.h"
#define f1 85
#define f2 41
#define f3 17
#define f4 8

const FSMState NextStateTable[4][2] =
{
//Active Inactive
		    {S2_Release, S1_Release},
		    {S3_Release, S2_Release},
		    {S4_Release, S3_Release},
		    {S1_Release, S4_Release}
};
#define S1_PRESS &FSMTable[0]
#define S1_RELEASE &FSMTable[1]
#define S2_PRESS &FSMTable[2]
#define S2_RELEASE &FSMTable[3]
#define S3_PRESS &FSMTable[4]
#define S3_RELEASE &FSMTable[5]
#define S4_PRESS &FSMTable[6]
#define S4_RELEASE &FSMTable[7]
const FSMTableType FSMTable[4] = {
// Next State
// Current State Active Inactive

{S1_Release, {S2_RELEASE, S1_RELEASE}},

{S2_Release, {S3_RELEASE, S2_RELEASE}},

{S3_Release, {S4_RELEASE, S3_RELEASE}},

{S4_Release, {S1_RELEASE, S4_RELEASE}}
};
void InitializeFSM(FSMType *FSM) //초기화
{
FSM->CurrentState = S1_Release;
FSM->StateCounter = 0;
}

FSMState NextStateFunction(FSMType *FSM)
{
	FSMState NextState = S1_Release;

	switch (FSM->CurrentState) {
	case S1_Release:
			NextState = S2_Release;
		break;
	case S2_Release:
			NextState = S3_Release;
		break;
	case S3_Release:
			NextState = S4_Release;
		break;
	case S4_Release:
			NextState = S1_Release;
		break;
}
return NextState;
}



void OutputFunction(FSMType *FSM)
{
	uint16_t max_counter = 0;
switch (FSM->CurrentState) {
case S1_Release:
	max_counter =f1;
break;
case S2_Release:
	max_counter =f2;
break;
case S3_Release:
	max_counter =f3;
break;
case S4_Release:
	max_counter =f4;
break;
}

      FSM->StateCounter++; // increase

if (FSM->StateCounter >= max_counter) {
       HAL_GPIO_TogglePin(Grn_LED_GPIO_Port, Grn_LED_Pin); // LED 토글
       FSM->StateCounter = 0; // reset
   }

}
